from . import models
from .database import schemas
from sqlalchemy.orm import Session
from fastapi import HTTPException

# -------------------- 2) /status

def get_match_by_id(
    matchId : int,
    session : Session
) -> schemas.MatchSchema:
    db_match = session.query(schemas.MatchSchema).filter(schemas.MatchSchema.id==matchId).first()
    return db_match


# -------------------- 3) /create

def post_match_by_id(
        match   : models.MatchModel,
        session : Session
) -> schemas.MatchSchema:
    # Check if match id is already used
    existing = get_match_by_id(matchId=match.id, session=session)
    if existing:
        raise HTTPException(status_code=400, detail="Match ID already exists.")
    # If not, create the new row for the matches
    db_match = schemas.MatchSchema(**match.model_dump())
    # Add the new row to the session
    session.add(db_match)
    # Update the databse
    session.commit()
    # Refresh the row with the information from databae: ID is autogenerated by the DB
    session.refresh(db_match)
    return db_match

# -------------------- 1) /move

def is_winner(
    board : str,
    player : str
) -> bool:
    '''
    Returns if the speficied player has won.
    '''
    # Win Scenarios
    lineas = [
        (0, 1, 2),  # Row 1
        (3, 4, 5),  # Row 2
        (6, 7, 8),  # Row 3
        (0, 3, 6),  # Column 1
        (1, 4, 7),  # Column 2
        (2, 5, 8),  # Column 3
        (0, 4, 8),  # Diagonal 1
        (2, 4, 6),  # Diagonal 2
    ]

    for i, j, k in lineas:
        if board[i] == board[j] == board[k] == player:
            return True


def check_move(
    match_db : schemas.MatchSchema,
    move : models.MoveModel,
):
    '''
    Check if a given move is legal in a given board.
    '''
    # 1) Check if match exists
    if not match_db:
        raise HTTPException(status_code=400, detail=f"Match ID ({move.matchId}) does not exists.")
    # 2) Check if the game is over
    if match_db.winner != None:
        raise HTTPException(status_code=400, detail=f"Match ID ({move.matchId}) is over. Player ID ({match_db.winner}) won.")
    # 3) Check if it is the proper player playing
    if match_db.turn != move.playerId:
        raise HTTPException(status_code=400, detail=f"Move player ID ({move.playerId}) does not match the turn ({match_db.turn}).")
    # 4) Check if the (x,y) is occupied
    board = match_db.board
    x = move.square.x-1
    y = move.square.y-1
    if board[3*x+y] != "_":
        raise HTTPException(status_code=400, detail=f"Square ({move.square.x},{move.square.y}) is occupied. Current board: ({match_db.board})")

def actualize_match(
    match_db : schemas.MatchSchema,
    move : models.MoveModel,
):
    # 1) Actualize board
    x = move.square.x-1
    y = move.square.y-1
    index = 3*x+y
    board_list = list(match_db.board)   
    board_list[index] = match_db.turn   
    match_db.board = "".join(board_list) 
    # 2) Actualize winnerr
    if is_winner(board = match_db.board, player=match_db.turn):
        match_db.winner = match_db.turn
    # 3) Actualize turn
    if match_db.turn == "X": 
        match_db.turn = "O"
    else:
        match_db.turn = "X"
    return match_db

def post_move(
    move : models.MoveModel,
    session : Session
):
    match_db = get_match_by_id(matchId=move.matchId, session=session)
    # Check if the move is valid
    check_move(move=move, match_db=match_db)
    # If does, create a new row for the moves table
    move_db = schemas.MoveSchema(
        matchId=move.matchId,
        playerId=move.playerId,
        x=move.square.x,
        y=move.square.y
    )
    session.add(move_db)
    # Modify the corresponding match row
    actualize_match(match_db=match_db, move=move)
    # Update the databse
    session.commit()
    # Refresh the row with the information from databae: ID is autogenerated by the DB
    session.refresh(move_db)
    session.refresh(match_db)

    return move_db, match_db