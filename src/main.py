import os

from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session

from . import models
from .database import core
from .database import schemas

# Connect to database: Creates engine and Sessions constructor.
db = core.DataBase("sqlite+pysqlite:///./tmp/tictactoe.db")

# Instantiate the web application
app = FastAPI()

# Endpoints operations
# 1) /move endpoint
@app.post("/move", status_code=200)
async def move(
    move : models.MoveModel
):
    return move

# 2) /status
def get_match_by_id(
    matchId : int,
    session : Session
):
    match = session.query(schemas.MatchSchema).filter(schemas.MatchSchema.id==matchId).first()
    return match

@app.get("/status", status_code=200)
def status(
    matchId : int,
    session : Session = Depends(db.get_session_to_db_FastAPI)
):
    match = get_match_by_id(matchId, session)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    return match

# 3) /create
def post_match_by_id(
        match   : models.MatchModel,
        session : Session
):
    # Check if match id is already used
    existing = get_match_by_id(matchId=match.id, session=session)
    if existing:
        raise HTTPException(status_code=400, detail="Match ID already exists.")
    # If not, create the new row in the database
    db_match = schemas.MatchSchema(**match.model_dump())
    # Add the new row to the session
    session.add(db_match)
    # Update the databse
    session.commit()
    # Refresh the row with the information from databae: ID is autogenerated by the DB and it is needed
    session.refresh(db_match)
    return db_match

@app.post("/create", status_code=200)
async def create(
    match   : models.MatchModel | None = None,
    session : Session = Depends(db.get_session_to_db_FastAPI)
):
    if match == None:
        match = models.MatchModel()
    db_match = post_match_by_id(match=match, session=session)
    return {"idMatch":db_match.id}